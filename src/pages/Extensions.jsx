import React, { useState, useEffect } from 'react';
import { toast } from 'react-toastify';
import MarketplaceHero from '../components/MarketplaceHero';
import MarketplaceControls from '../components/MarketplaceControls';
import ExtensionsGrid from '../components/ExtensionsGrid';

const Extensions = () => {
  const [extensions, setExtensions] = useState([]);
  const [currentFilter, setCurrentFilter] = useState('all');
  const [currentSearch, setCurrentSearch] = useState('');
  const [loading, setLoading] = useState(true);

  const baseExtensions = [
    {
      id: 'plotune_sandbox_extension',
      app_id: 'plotune_sandbox_extension',
      name: 'Plotune SandBox Extension',
      description: 'Random data generator for SandBox environment in Plotune',
      tags: ['verified', 'core'],
      os: ["Linux", "Windows"],
      repo: 'https://github.com/baksi-org/plotune-sandbox-ext',
      deployment: 'https://github.com/baksi-org/plotune-sandbox-ext/releases',
      web: 'https://plotune.net/',
      documentation: 'https://github.com/baksi-org/plotune-sandbox-ext',
      is_verified: true,
      author: 'Plotune SDK Team',
      logo: 'https://www.gravatar.com/avatar/5ff75ad1008fe01582efcae23b54f175a947461a3aee3e14ac77c13c0b0c51d3?d=monsterid'
    },
    {
      id: 'plotune_relay_ext',
      app_id: 'plotune_relay_ext',
      name: 'Plotune Relay Extension',
      description: 'Universal data relay extension for Plotune Core. Supports WebSocket and HTTP polling sources.',
      tags: ['verified', 'core'],
      os: ["Linux", "Windows"],
      repo: 'https://github.com/baksi-org/plotune-relay-ext',
      deployment: 'https://github.com/baksi-org/plotune-relay-ext/releases',
      web: 'https://plotune.net/',
      documentation: 'https://github.com/baksi-org/plotune-relay-ext',
      is_verified: true,
      author: 'Plotune SDK Team',
      logo: 'https://www.gravatar.com/avatar/eeec87c03bb42a9817b1feeeae3448bf7378381fcc0abc4428d259ee4ebd80ee?d=monsterid'
    },
    {
      id: 'plotune_arduino_ext',
      app_id: 'plotune_arduino_ext',
      name: 'Plotune Arduino Extension',
      description: 'Plug-and-play Arduino serial data acquisition and real-time streaming for Plotune Core.',
      tags: ['verified', 'core'],
      os: ["Linux", "Windows"],
      repo: 'https://github.com/baksi-org/plotune-arduino-ext',
      deployment: 'https://github.com/baksi-org/plotune-arduino-ext/releases',
      web: 'https://plotune.net/',
      documentation: 'https://github.com/baksi-org/plotune-arduino-ext',
      is_verified: true,
      author: 'Plotune SDK Team',
      logo: 'https://www.gravatar.com/avatar/c1b5f34e4a0335ace8cc4184e1f5a07b71b1b1dad77933276c646c43a0a83389?d=monsterid'
    },
    {
      id: 'plotune_simple_reader_ext',
      app_id: 'plotune_simple_reader_ext',
      name: 'Plotune Simple Reader',
      description: 'File reader, PLTX, HDF5, Arrow, CSV, XLSX',
      tags: ['verified', 'core'],
      os: ["Linux", "Windows"],
      repo: 'https://github.com/baksi-org/plotune-arduino-ext',
      deployment: 'https://github.com/baksi-org/plotune-simple-reader-ext/releases',
      web: 'https://plotune.net/',
      documentation: 'https://github.com/baksi-org/plotune-simple-reader-ext',
      is_verified: true,
      author: 'Plotune SDK Team',
      logo: 'https://www.gravatar.com/avatar/bf5360a203eea8e897bd60e34c52ac18090ae79464fd56b4800ee1ce9136397e?d=monsterid'
    }
  ];

  useEffect(() => {
    console.log("Initializing Extensions component...");
    loadExtensions();
  }, []);

  const fetchLatestRelease = async (repoUrl) => {
    try {
      const urlParts = repoUrl.split('/');
      const owner = urlParts[urlParts.length - 2];
      const repo = urlParts[urlParts.length - 1];
      
      const apiUrl = `https://api.github.com/repos/${owner}/${repo}/releases/latest`;
      
      console.log(`Fetching latest release from: ${apiUrl}`);
      
      const response = await fetch(apiUrl);
      
      if (!response.ok) {
        if (response.status === 404) {
          console.log(`No releases found for ${owner}/${repo}`);
          return null;
        }
        throw new Error(`GitHub API returned ${response.status}`);
      }
      
      const releaseData = await response.json();
      console.log(`Release data for ${owner}/${repo}:`, releaseData);
      
      return {
        version: releaseData.tag_name,
        last_updated: releaseData.published_at,
        download_url: releaseData.html_url,
        assets: releaseData.assets
      };
    } catch (error) {
      console.error(`Error fetching release for ${repoUrl}:`, error);
      return null;
    }
  };

  const loadExtensions = async () => {
    console.log("Loading extensions...");
    setLoading(true);
    
    try {
      const extensionsWithReleases = await loadBaseExtensions();
      setExtensions(extensionsWithReleases);
    } catch (error) {
      console.error("Error loading extensions:", error);
      toast.error("Failed to load extensions");
    } finally {
      setLoading(false);
    }
  };

  const loadBaseExtensions = async () => {
    try {
      console.log("Fetching release information for extensions...");
      
      const extensionsWithReleases = await Promise.all(
        baseExtensions.map(async (ext) => {
          try {
            const releaseInfo = await fetchLatestRelease(ext.repo);
            
            return {
              ...ext,
              version: releaseInfo?.version || 'v0.0.0',
              last_updated: releaseInfo?.last_updated || new Date().toISOString().split('T')[0],
              core_version: '>=1.0.0',
              deployment: ext.deployment
            };
          } catch (error) {
            console.error(`Error processing extension ${ext.name}:`, error);
            return {
              ...ext,
              version: 'v0.0.0',
              last_updated: new Date().toISOString().split('T')[0],
              core_version: '>=1.0.0',
            };
          }
        })
      );
      
      console.log("Extensions with release info:", extensionsWithReleases);
      return extensionsWithReleases;
    } catch (error) {
      console.log("Error fetching releases, using base extension data:", error.message);
      
      return baseExtensions.map(ext => ({
        ...ext,
        version: 'v0.0.0',
        last_updated: new Date().toISOString().split('T')[0],
        core_version: '>=1.0.0',
      }));
    }
  };

  const matchesFilter = (extension) => {
    if (currentSearch) {
      const searchLower = currentSearch.toLowerCase();
      const matchesSearch = 
        extension.name.toLowerCase().includes(searchLower) ||
        extension.description.toLowerCase().includes(searchLower) ||
        (extension.tags && extension.tags.some(tag => tag.toLowerCase().includes(searchLower))) ||
        extension.author.toLowerCase().includes(searchLower);
      
      if (!matchesSearch) return false;
    }

    switch (currentFilter) {
      case 'verified':
        return extension.is_verified;
      case 'core':
        return extension.tags?.includes('core');
      case 'package':
        return extension.tags?.includes('package');
      case 'stream':
        return extension.tags?.includes('stream');
      case 'cloud':
        return extension.tags?.includes('cloud');
      default:
        return true;
    }
  };

  const installExtension = async (id) => {
    const extension = extensions.find(ext => ext.id === id);
    if (!extension) {
      toast.error('Extension not found');
      return;
    }

    const customUrl = `plotune://install?method=github&source=github&repo=${encodeURIComponent(extension.deployment)}&uid=${extension.id}`;
    
    console.log("Attempting to install via custom URL:", customUrl);
    
    window.location.href = customUrl;
    
    setTimeout(() => {
      if (!document.hidden) {
        console.log("Custom URL failed, redirecting to download page");
        toast.info("Plotune not detected. Redirecting to download page...");
        window.open('/#/download', '_blank');
      }
    }, 1500);
  };

  const visitWebsite = (url) => {
    if (url) {
      window.open(url, '_blank');
    } else {
      toast.error('No website available for this extension.');
    }
  };

  const visitRepo = (url) => {
    if (url) {
      window.open(url, '_blank');
    } else {
      toast.error('No repository available for this extension.');
    }
  };

  const filteredExtensions = extensions.filter(matchesFilter);

  console.log("Current state:", { 
    extensionsCount: extensions.length, 
    filteredCount: filteredExtensions.length,
    loading
  });

  return (
    <>
      <MarketplaceHero />
      <MarketplaceControls
        currentFilter={currentFilter}
        setCurrentFilter={setCurrentFilter}
        currentSearch={currentSearch}
        setCurrentSearch={setCurrentSearch}
        extensionCount={filteredExtensions.length}
        totalCount={extensions.length}
      />
      <ExtensionsGrid
        extensions={filteredExtensions}
        loading={loading}
        installExtension={installExtension}
        visitWebsite={visitWebsite}
        visitRepo={visitRepo}
      />
    </>
  );
};

export default Extensions;